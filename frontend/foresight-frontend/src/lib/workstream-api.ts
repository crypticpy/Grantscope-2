/**
 * Workstream API Client
 *
 * API functions for managing workstream Kanban boards.
 * Handles card operations including fetching, adding, updating, removing,
 * as well as triggering deep dives and auto-population of workstreams.
 */

const API_BASE_URL = import.meta.env.VITE_API_URL || 'http://localhost:8000';

// ============================================================================
// Types
// ============================================================================

/**
 * Valid Kanban column statuses for workstream cards.
 * Cards flow through these stages as part of the research workflow:
 * - inbox: Newly added cards awaiting initial triage
 * - screening: Cards being evaluated for relevance
 * - research: Cards actively being researched
 * - brief: Cards ready for or in briefing stage
 * - watching: Cards to monitor for future developments
 * - archived: Completed or dismissed cards
 */
export type KanbanStatus = 'inbox' | 'screening' | 'research' | 'brief' | 'watching' | 'archived';

/**
 * Detailed card information embedded within workstream cards.
 * Contains core card metadata and scoring for display in Kanban view.
 */
export interface CardDetails {
  /** Unique identifier for the card */
  id: string;
  /** Display name of the card */
  name: string;
  /** URL-safe slug for the card */
  slug: string;
  /** Brief description or summary of the card */
  summary: string;
  /** UUID of the pillar this card belongs to */
  pillar_id: string;
  /** Numeric stage identifier (1-8) representing maturity */
  stage_id: number;
  /** Innovation horizon classification */
  horizon: 'H1' | 'H2' | 'H3';
  /** Novelty score (0-100) indicating how new/unique the concept is */
  novelty_score: number;
  /** Maturity score (0-100) indicating development stage */
  maturity_score: number;
  /** Optional list of top 25 relevance terms/topics */
  top25_relevance?: string[];
}

/**
 * Workstream card representing a card's presence and state within a workstream.
 * Combines the card reference with workstream-specific metadata like status,
 * position, notes, and reminders.
 */
export interface WorkstreamCard {
  /** Unique identifier for this workstream-card relationship */
  id: string;
  /** UUID of the underlying intelligence card */
  card_id: string;
  /** UUID of the workstream this card belongs to */
  workstream_id: string;
  /** Current Kanban column status */
  status: KanbanStatus;
  /** Position within the column for ordering (lower = higher) */
  position: number;
  /** User notes attached to this card in the workstream */
  notes: string | null;
  /** Optional reminder timestamp (ISO format) */
  reminder_at: string | null;
  /** How the card was added to the workstream */
  added_from: 'manual' | 'auto' | 'follow';
  /** Timestamp when the card was added (ISO format) */
  added_at: string;
  /** Timestamp of last update (ISO format) */
  updated_at: string;
  /** Embedded card details for display */
  card: CardDetails;
}

/**
 * Cards grouped by their Kanban status.
 * Each status key contains an array of workstream cards for that column.
 */
export interface GroupedWorkstreamCards {
  inbox: WorkstreamCard[];
  screening: WorkstreamCard[];
  research: WorkstreamCard[];
  brief: WorkstreamCard[];
  watching: WorkstreamCard[];
  archived: WorkstreamCard[];
}

/**
 * Response from triggering a deep dive analysis on a card.
 */
export interface DeepDiveResponse {
  /** Unique identifier for the deep dive task */
  id: string;
  /** Current status of the deep dive task */
  status: string;
  /** Type of task (typically 'deep_dive') */
  task_type: string;
}

/**
 * Response from auto-populating a workstream with recommended cards.
 */
export interface AutoPopulateResponse {
  /** Number of cards successfully added */
  added: number;
  /** The newly added workstream cards */
  cards: WorkstreamCard[];
}

/**
 * Executive brief generation status values.
 * Represents the lifecycle of an AI-generated brief:
 * - pending: Brief generation has been requested but not started
 * - generating: Brief is actively being generated by the AI
 * - completed: Brief has been successfully generated
 * - failed: Brief generation encountered an error
 */
export type BriefGenerationStatus = 'pending' | 'generating' | 'completed' | 'failed';

/**
 * Executive brief for a workstream card.
 * Contains AI-generated content summarizing the card for leadership review.
 */
export interface ExecutiveBrief {
  /** Unique identifier for the brief */
  id: string;
  /** UUID of the workstream card this brief belongs to */
  workstream_card_id: string;
  /** UUID of the underlying intelligence card */
  card_id: string;
  /** UUID of the user who created/requested the brief */
  created_by: string;
  /** Current generation status */
  status: BriefGenerationStatus;
  /** Version number (1, 2, 3, etc.) */
  version: number;
  /** Metadata about sources discovered since previous version */
  sources_since_previous: {
    count: number;
    since_version: number;
    since_date: string;
  } | null;
  /** Structured brief content (JSON format) */
  content: Record<string, unknown> | null;
  /** Markdown-formatted brief content for display */
  content_markdown: string | null;
  /** Short summary of the brief (1-2 sentences) */
  summary: string | null;
  /** Timestamp when brief generation completed (ISO format) */
  generated_at: string | null;
  /** Time taken to generate the brief in milliseconds */
  generation_time_ms: number | null;
  /** AI model used for generation */
  model_used: string | null;
  /** Error message if generation failed */
  error_message: string | null;
  /** Creation timestamp (ISO format) */
  created_at: string;
  /** Last update timestamp (ISO format) */
  updated_at: string;
}

/**
 * Lightweight status response for polling brief generation progress.
 * Used to check if generation is complete without fetching full content.
 */
export interface BriefStatus {
  /** Brief identifier */
  id: string;
  /** Current generation status */
  status: BriefGenerationStatus;
  /** Version number being generated */
  version: number;
  /** Short summary (available once completed) */
  summary: string | null;
  /** Error message (available if failed) */
  error_message: string | null;
  /** Timestamp when generation completed */
  generated_at: string | null;
  /** Progress message during generation */
  progress_message: string | null;
}

/**
 * Response from initiating brief generation.
 */
export interface GenerateBriefResponse {
  /** Unique identifier for the brief */
  id: string;
  /** Initial status (typically 'pending' or 'generating') */
  status: string;
  /** Version number being generated */
  version: number;
  /** Status message */
  message: string;
}

/**
 * Compact version item for version history display.
 */
export interface BriefVersionListItem {
  /** Unique identifier for this version */
  id: string;
  /** Version number (1, 2, 3, etc.) */
  version: number;
  /** Generation status */
  status: BriefGenerationStatus;
  /** Short summary for preview */
  summary: string | null;
  /** Metadata about new sources since previous version */
  sources_since_previous: {
    count: number;
    since_version: number;
    since_date: string;
  } | null;
  /** Timestamp when generation completed */
  generated_at: string | null;
  /** Timestamp when record was created */
  created_at: string;
  /** AI model used */
  model_used: string | null;
}

/**
 * Response containing all versions of a brief.
 */
export interface BriefVersionsResponse {
  /** UUID of the workstream card */
  workstream_card_id: string;
  /** UUID of the underlying card */
  card_id: string;
  /** Total number of versions */
  total_versions: number;
  /** List of versions, newest first */
  versions: BriefVersionListItem[];
}

// ============================================================================
// Bulk Brief Export Types
// ============================================================================

/**
 * Status of cards for bulk export.
 */
export interface BulkBriefCardStatus {
  card_id: string;
  card_name: string;
  has_brief: boolean;
  brief_status: string | null;
  position: number;
}

/**
 * Response for bulk brief status check.
 */
export interface BulkBriefStatusResponse {
  total_cards: number;
  cards_with_briefs: number;
  cards_ready: number;
  card_statuses: BulkBriefCardStatus[];
}

/**
 * Request for bulk brief export.
 */
export interface BulkExportRequest {
  format: 'pptx' | 'pdf';
  card_order: string[];
}

/**
 * Response for bulk brief export initiation.
 */
export interface BulkExportResponse {
  status: string;
  message: string;
  portfolio_id?: string;
  total_cards?: number;
  format?: string;
  pptx_url?: string;
  pdf_path?: string;
  error?: string;
  using_fallback?: boolean;
}

// ============================================================================
// Helper Functions
// ============================================================================

/**
 * Generic API request helper with authentication and error handling.
 * Follows the established pattern from discovery-api.ts.
 *
 * @param endpoint - API endpoint path (without base URL)
 * @param token - Bearer authentication token
 * @param options - Fetch options (method, body, headers, etc.)
 * @returns Typed response from the API
 * @throws Error with message from API response or generic error
 */
async function apiRequest<T>(
  endpoint: string,
  token: string,
  options: RequestInit = {}
): Promise<T> {
  const response = await fetch(`${API_BASE_URL}${endpoint}`, {
    ...options,
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${token}`,
      ...options.headers,
    },
  });

  if (!response.ok) {
    const error = await response.json().catch(() => ({ message: 'Request failed' }));
    throw new Error(error.message || error.detail || `API error: ${response.status}`);
  }

  // Handle 204 No Content
  if (response.status === 204) {
    return undefined as T;
  }

  return response.json();
}

/**
 * Creates an empty grouped cards structure with all status arrays initialized.
 *
 * @returns Empty GroupedWorkstreamCards object
 */
function createEmptyGroupedCards(): GroupedWorkstreamCards {
  return {
    inbox: [],
    screening: [],
    research: [],
    brief: [],
    watching: [],
    archived: [],
  };
}

/**
 * Groups an array of workstream cards by their status.
 * Exported for potential client-side grouping needs.
 *
 * @param cards - Array of workstream cards to group
 * @returns Cards grouped by Kanban status
 */
export function groupCardsByStatus(cards: WorkstreamCard[]): GroupedWorkstreamCards {
  const grouped = createEmptyGroupedCards();

  for (const card of cards) {
    if (card.status in grouped) {
      grouped[card.status].push(card);
    }
  }

  // Sort each column by position
  for (const status of Object.keys(grouped) as KanbanStatus[]) {
    grouped[status].sort((a, b) => a.position - b.position);
  }

  return grouped;
}

// ============================================================================
// API Functions
// ============================================================================

/**
 * Fetches all cards in a workstream, grouped by Kanban status.
 * Cards within each status group are sorted by position.
 *
 * @param token - Bearer authentication token
 * @param workstreamId - UUID of the workstream
 * @returns Cards grouped by status for Kanban display
 *
 * @example
 * ```typescript
 * const grouped = await fetchWorkstreamCards(token, workstreamId);
 * console.log(`${grouped.inbox.length} cards in inbox`);
 * ```
 */
export async function fetchWorkstreamCards(
  token: string,
  workstreamId: string
): Promise<GroupedWorkstreamCards> {
  // Backend returns already grouped response
  const response = await apiRequest<GroupedWorkstreamCards>(
    `/api/v1/me/workstreams/${workstreamId}/cards`,
    token
  );

  // Ensure all status keys exist with proper defaults
  return {
    inbox: response.inbox || [],
    screening: response.screening || [],
    research: response.research || [],
    brief: response.brief || [],
    watching: response.watching || [],
    archived: response.archived || [],
  };
}

/**
 * Adds a card to a workstream with optional initial status and notes.
 * The card will be added to the specified status column (defaults to 'inbox')
 * at the end of the column's card list.
 *
 * @param token - Bearer authentication token
 * @param workstreamId - UUID of the workstream
 * @param cardId - UUID of the card to add
 * @param status - Initial Kanban status (defaults to 'inbox')
 * @param notes - Optional notes to attach to the card
 * @returns The newly created workstream card
 *
 * @example
 * ```typescript
 * const card = await addCardToWorkstream(token, wsId, cardId, 'screening', 'Review this week');
 * ```
 */
export async function addCardToWorkstream(
  token: string,
  workstreamId: string,
  cardId: string,
  status?: KanbanStatus,
  notes?: string
): Promise<WorkstreamCard> {
  const body: Record<string, unknown> = { card_id: cardId };

  if (status !== undefined) {
    body.status = status;
  }

  if (notes !== undefined) {
    body.notes = notes;
  }

  return apiRequest<WorkstreamCard>(
    `/api/v1/me/workstreams/${workstreamId}/cards`,
    token,
    {
      method: 'POST',
      body: JSON.stringify(body),
    }
  );
}

/**
 * Updates a workstream card's properties.
 * Supports updating status (moving between columns), position (reordering),
 * notes, and reminder settings.
 *
 * @param token - Bearer authentication token
 * @param workstreamId - UUID of the workstream
 * @param cardId - UUID of the workstream card (not the underlying card)
 * @param updates - Object containing fields to update
 * @returns The updated workstream card
 *
 * @example
 * ```typescript
 * // Move card to research column at position 0
 * const updated = await updateWorkstreamCard(token, wsId, cardId, {
 *   status: 'research',
 *   position: 0
 * });
 *
 * // Add a reminder for next week
 * const withReminder = await updateWorkstreamCard(token, wsId, cardId, {
 *   reminder_at: '2024-02-01T09:00:00Z'
 * });
 * ```
 */
export async function updateWorkstreamCard(
  token: string,
  workstreamId: string,
  cardId: string,
  updates: {
    status?: KanbanStatus;
    position?: number;
    notes?: string;
    reminder_at?: string | null;
  }
): Promise<WorkstreamCard> {
  return apiRequest<WorkstreamCard>(
    `/api/v1/me/workstreams/${workstreamId}/cards/${cardId}`,
    token,
    {
      method: 'PATCH',
      body: JSON.stringify(updates),
    }
  );
}

/**
 * Removes a card from a workstream.
 * This removes the card from the user's workstream view but does not
 * delete the underlying intelligence card.
 *
 * @param token - Bearer authentication token
 * @param workstreamId - UUID of the workstream
 * @param cardId - UUID of the workstream card to remove
 *
 * @example
 * ```typescript
 * await removeCardFromWorkstream(token, workstreamId, cardId);
 * ```
 */
export async function removeCardFromWorkstream(
  token: string,
  workstreamId: string,
  cardId: string
): Promise<void> {
  return apiRequest<void>(
    `/api/v1/me/workstreams/${workstreamId}/cards/${cardId}`,
    token,
    {
      method: 'DELETE',
    }
  );
}

/**
 * Triggers a deep dive analysis on a card.
 * Initiates an async background task that performs in-depth research
 * and analysis on the specified card, enriching its data.
 *
 * @param token - Bearer authentication token
 * @param workstreamId - UUID of the workstream
 * @param cardId - UUID of the workstream card to analyze
 * @returns Deep dive task information including task ID and status
 *
 * @example
 * ```typescript
 * const task = await triggerDeepDive(token, wsId, cardId);
 * console.log(`Deep dive task ${task.id} started with status: ${task.status}`);
 * ```
 */
export async function triggerDeepDive(
  token: string,
  workstreamId: string,
  cardId: string
): Promise<DeepDiveResponse> {
  return apiRequest<DeepDiveResponse>(
    `/api/v1/me/workstreams/${workstreamId}/cards/${cardId}/deep-dive`,
    token,
    {
      method: 'POST',
    }
  );
}

/**
 * Auto-populates a workstream with recommended cards.
 * Uses the workstream's configuration (pillars, goals, filters) to
 * find and add relevant cards automatically to the inbox.
 *
 * @param token - Bearer authentication token
 * @param workstreamId - UUID of the workstream
 * @param limit - Maximum number of cards to add (optional, uses server default)
 * @returns Number of cards added and the newly added workstream cards
 *
 * @example
 * ```typescript
 * const result = await autoPopulateWorkstream(token, wsId, 10);
 * console.log(`Added ${result.added} cards to the workstream`);
 * ```
 */
export async function autoPopulateWorkstream(
  token: string,
  workstreamId: string,
  limit?: number
): Promise<AutoPopulateResponse> {
  const body: Record<string, unknown> = {};

  if (limit !== undefined) {
    body.limit = limit;
  }

  return apiRequest<AutoPopulateResponse>(
    `/api/v1/me/workstreams/${workstreamId}/auto-populate`,
    token,
    {
      method: 'POST',
      body: JSON.stringify(body),
    }
  );
}

// ============================================================================
// Research Status API Functions
// ============================================================================

/**
 * Research status for a card in a workstream.
 */
export interface WorkstreamResearchStatus {
  /** UUID of the underlying card */
  card_id: string;
  /** UUID of the research task */
  task_id: string;
  /** Type of research (quick_update, deep_research) */
  task_type: 'quick_update' | 'deep_research';
  /** Task status */
  status: 'queued' | 'processing' | 'completed' | 'failed';
  /** When research started */
  started_at?: string;
  /** When research completed */
  completed_at?: string;
}

/**
 * Response containing active research tasks for workstream cards.
 */
export interface WorkstreamResearchStatusResponse {
  tasks: WorkstreamResearchStatus[];
}

/**
 * Fetches active research tasks for cards in a workstream.
 * Returns queued/processing tasks and recently completed tasks (last hour).
 * Used to show research progress indicators on kanban cards.
 *
 * @param token - Bearer authentication token
 * @param workstreamId - UUID of the workstream
 * @returns Research status for cards with active or recent tasks
 *
 * @example
 * ```typescript
 * const { tasks } = await fetchResearchStatus(token, wsId);
 * tasks.forEach(t => console.log(`Card ${t.card_id}: ${t.status}`));
 * ```
 */
export async function fetchResearchStatus(
  token: string,
  workstreamId: string
): Promise<WorkstreamResearchStatusResponse> {
  return apiRequest<WorkstreamResearchStatusResponse>(
    `/api/v1/me/workstreams/${workstreamId}/research-status`,
    token
  );
}

// ============================================================================
// Executive Brief API Functions
// ============================================================================

/**
 * Initiates executive brief generation for a workstream card.
 * This is an async operation - the brief will be generated in the background.
 * Use getBriefStatus() to poll for completion, then getBrief() to fetch the result.
 *
 * @param token - Bearer authentication token
 * @param workstreamId - UUID of the workstream
 * @param cardId - UUID of the workstream card (not the underlying card)
 * @returns Initial response with brief ID and status
 *
 * @example
 * ```typescript
 * const response = await generateBrief(token, wsId, cardId);
 * console.log(`Brief ${response.id} generation started with status: ${response.status}`);
 * // Poll getBriefStatus() until status is 'completed' or 'failed'
 * ```
 */
export async function generateBrief(
  token: string,
  workstreamId: string,
  cardId: string
): Promise<GenerateBriefResponse> {
  return apiRequest<GenerateBriefResponse>(
    `/api/v1/me/workstreams/${workstreamId}/cards/${cardId}/brief`,
    token,
    {
      method: 'POST',
    }
  );
}

/**
 * Fetches the full executive brief for a workstream card.
 * Call this after brief generation is complete to get the full content.
 *
 * @param token - Bearer authentication token
 * @param workstreamId - UUID of the workstream
 * @param cardId - UUID of the workstream card
 * @param version - Optional specific version to fetch (defaults to latest)
 * @returns The complete executive brief with all content
 *
 * @example
 * ```typescript
 * const brief = await getBrief(token, wsId, cardId);
 * if (brief.status === 'completed') {
 *   console.log(brief.content_markdown);
 * }
 * // Fetch a specific version
 * const v1 = await getBrief(token, wsId, cardId, 1);
 * ```
 */
export async function getBrief(
  token: string,
  workstreamId: string,
  cardId: string,
  version?: number
): Promise<ExecutiveBrief> {
  const url = version
    ? `/api/v1/me/workstreams/${workstreamId}/cards/${cardId}/brief?version=${version}`
    : `/api/v1/me/workstreams/${workstreamId}/cards/${cardId}/brief`;
  return apiRequest<ExecutiveBrief>(url, token);
}

/**
 * Fetches all versions of briefs for a workstream card.
 * Returns versions ordered by version number descending (newest first).
 *
 * @param token - Bearer authentication token
 * @param workstreamId - UUID of the workstream
 * @param cardId - UUID of the workstream card
 * @returns List of all brief versions with metadata
 *
 * @example
 * ```typescript
 * const { versions, total_versions } = await getBriefVersions(token, wsId, cardId);
 * versions.forEach(v => console.log(`v${v.version}: ${v.summary}`));
 * ```
 */
export async function getBriefVersions(
  token: string,
  workstreamId: string,
  cardId: string
): Promise<BriefVersionsResponse> {
  return apiRequest<BriefVersionsResponse>(
    `/api/v1/me/workstreams/${workstreamId}/cards/${cardId}/brief/versions`,
    token
  );
}

/**
 * Checks the current status of brief generation.
 * Use this for polling during async brief generation to minimize data transfer.
 * Once status is 'completed', call getBrief() to fetch the full content.
 *
 * @param token - Bearer authentication token
 * @param workstreamId - UUID of the workstream
 * @param cardId - UUID of the workstream card
 * @returns Lightweight status object with generation progress
 *
 * @example
 * ```typescript
 * const status = await getBriefStatus(token, wsId, cardId);
 * if (status.status === 'completed') {
 *   const brief = await getBrief(token, wsId, cardId);
 * } else if (status.status === 'failed') {
 *   console.error(status.error_message);
 * }
 * ```
 */
export async function getBriefStatus(
  token: string,
  workstreamId: string,
  cardId: string
): Promise<BriefStatus> {
  return apiRequest<BriefStatus>(
    `/api/v1/me/workstreams/${workstreamId}/cards/${cardId}/brief/status`,
    token
  );
}

/**
 * Exports an executive brief in the specified format.
 * Downloads the brief content (not the original card) as PDF or PowerPoint.
 *
 * @param token - Bearer authentication token
 * @param workstreamId - UUID of the workstream
 * @param cardId - UUID of the workstream card
 * @param format - Export format ('pdf' or 'pptx')
 * @param version - Optional version number to export (defaults to latest)
 * @returns true if export was successful
 *
 * @example
 * ```typescript
 * const success = await exportBrief(token, wsId, cardId, 'pdf');
 * if (success) {
 *   console.log('Brief downloaded as PDF');
 * }
 * ```
 */
export async function exportBrief(
  token: string,
  workstreamId: string,
  cardId: string,
  format: 'pdf' | 'pptx',
  version?: number
): Promise<boolean> {
  const url = version
    ? `${API_BASE_URL}/api/v1/me/workstreams/${workstreamId}/cards/${cardId}/brief/export/${format}?version=${version}`
    : `${API_BASE_URL}/api/v1/me/workstreams/${workstreamId}/cards/${cardId}/brief/export/${format}`;

  try {
    const response = await fetch(url, {
      method: 'GET',
      headers: {
        Authorization: `Bearer ${token}`,
      },
    });

    if (!response.ok) {
      const contentType = response.headers.get('content-type');
      if (contentType?.includes('application/json')) {
        const errorData = await response.json().catch(() => ({}));
        throw new Error(errorData.detail || errorData.message || `Export failed: ${response.status}`);
      }
      throw new Error(`Export failed: ${response.status}`);
    }

    // Get the blob and trigger download
    const blob = await response.blob();

    // Extract filename from Content-Disposition header or use default
    const contentDisposition = response.headers.get('content-disposition');
    let filename = `brief-export.${format}`;

    if (contentDisposition) {
      const filenameMatch = contentDisposition.match(/filename[^;=\n]*=((['"]).*?\2|[^;\n]*)/);
      if (filenameMatch && filenameMatch[1]) {
        filename = filenameMatch[1].replace(/['"]/g, '');
      }
    }

    // Create download link and trigger click
    const downloadUrl = window.URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = downloadUrl;
    link.download = filename;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    window.URL.revokeObjectURL(downloadUrl);

    return true;
  } catch (error) {
    console.error('Brief export failed:', error);
    throw error;
  }
}

// ============================================================================
// Bulk Brief Export Functions
// ============================================================================

/**
 * Get the status of all cards in the Brief column for bulk export.
 * Returns information about which cards have completed briefs.
 *
 * @param token - Bearer authentication token
 * @param workstreamId - UUID of the workstream
 * @returns Status of all cards in the Brief column
 */
export async function getBulkBriefStatus(
  token: string,
  workstreamId: string
): Promise<BulkBriefStatusResponse> {
  return apiRequest<BulkBriefStatusResponse>(
    `/api/v1/me/workstreams/${workstreamId}/bulk-brief-status`,
    token
  );
}

/**
 * Export multiple briefs as a single portfolio presentation.
 * Creates an AI-synthesized portfolio combining all selected briefs.
 * Handles both file downloads and JSON responses.
 *
 * @param token - Bearer authentication token
 * @param workstreamId - UUID of the workstream
 * @param format - Export format ('pptx' or 'pdf')
 * @param cardOrder - Ordered array of card IDs (from Kanban position)
 * @returns BulkExportResponse with status and optional URL
 */
export async function exportBulkBriefs(
  token: string,
  workstreamId: string,
  format: 'pptx' | 'pdf',
  cardOrder: string[]
): Promise<BulkExportResponse> {
  const response = await fetch(
    `${API_BASE_URL}/api/v1/me/workstreams/${workstreamId}/bulk-brief-export`,
    {
      method: 'POST',
      headers: {
        Authorization: `Bearer ${token}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        format,
        card_order: cardOrder,
      }),
    }
  );

  if (!response.ok) {
    const contentType = response.headers.get('content-type');
    if (contentType?.includes('application/json')) {
      const errorData = await response.json().catch(() => ({}));
      throw new Error(errorData.detail || errorData.message || `Export failed: ${response.status}`);
    }
    throw new Error(`Export failed: ${response.status}`);
  }

  // Check content type to determine response handling
  const contentType = response.headers.get('content-type');
  
  // If JSON response (unlikely but handle it)
  if (contentType?.includes('application/json')) {
    return response.json();
  }
  
  // File download response - extract and trigger download
  const blob = await response.blob();
  const contentDisposition = response.headers.get('content-disposition');
  let filename = `portfolio-export.${format}`;

  if (contentDisposition) {
    const filenameMatch = contentDisposition.match(/filename[^;=\n]*=((['"]).*?\2|[^;\n]*)/);
    if (filenameMatch && filenameMatch[1]) {
      filename = filenameMatch[1].replace(/['"]/g, '');
    }
  }

  // Trigger download
  const downloadUrl = window.URL.createObjectURL(blob);
  const link = document.createElement('a');
  link.href = downloadUrl;
  link.download = filename;
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  window.URL.revokeObjectURL(downloadUrl);

  // Return success response
  return {
    status: 'success',
    message: 'Portfolio downloaded successfully',
    format,
    total_cards: cardOrder.length,
  };
}
